# 第七章 链接

.c -> 预处理 -> .i -> c编译器 -> .s ->汇编器 -> .o -> 链接 -> .exe

## 1. 几个概念:
### 1. 可重定向目标文件:
1. .o文件就是可重定向目标文件，是一个一个的二进制模块， 但由于每一个模块是单独的， 并且地址也是逻辑地址，所以不能够运行，因此需要对其进行链接成可执行文件。

2. 为了方便理解，以windows系统为例，可重定向目标文件就是.o ， 静态库文件就是.a , 可执行文件就是.exe


### 2. ELF文件:
1. 百度百科: 在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。

    
2. .o文件.exe可执行文件.a文件 都是elf文件, .o和.exe就不说了，
    .a文件是静态库文件, 由是多个.o文件的集合 
        

#### elf文件的组成:
1. ELF头:
        以一个16字节的序列开始，这16个字节描述了该系统的字大小和序列顺序。
        剩下的部分为: 头大小，目标文件类型(是.o 还是.exe 还是.a )) ， 机器类型... 都是助于链接器进行语法分析的信息.

2. ELF节:
    1. .text: 已经编译了的机器代码
    2. .rodata: 只读数据
    3. .data: 已经初始化过的全局变量和静态变量.  
    4. .bss: 未初始化的静态变量和已经初始化为0的全局变量,  局部变量在运行时存在于栈中，不会保存在ELF里.
    5. COMMON: 未初始化的全局变量
    6. .symtab: 符号表, 记录了在程序中“定义” 和“引用” 的函数和全局变量的信息.  这里多说两句，定义很好理解，就是这个
    模块里已经对某个变量或函数明确定义过了(变量是赋值，函数是实现完毕了) ， 而引用可能是引用的外部函数， 链接的目的之一就是把
    模块中的相互调用给整合到一起.  再多说一句，这里的符号表和编译器里的符号表不一样，这里只有函数和全局变量，没有局部变量.
    7. .rel.text: 用于重定向的位置列表，里面保存**重定向条目** ，重定向条目包含4个信息，分别是函数符号在.text里的偏移位置, 函数符号(就是函数名)，重定向类型(例如相对，绝对)，根据重定向类型来做调整的一个常量。 text里的每个可重定向该条目，用于找到一个函数符号的位置。
    8. .rel.data: 用于重定向的位置列表，里面保存**重定向条目** ，和上一个一样，只不过这个是用来记录全局和静态变量的。
    9. .debug: 用于调试的符号表.
    10. .line: .text表中的机器代码和.c文件里的代码关于第几行的映射关系
    11. .strtab: 字符串表，包含了.symtab和.debug中的符号表.

3. 节头部表: 用于描述目标文件的节。

## 2. 链接的第一步: 符号翻译
因为可重定向目标文件是一个一个的模块， 其中有一些外部引用， 而这一步的目标就是找到每一个外部引用！ 

### 2.1 命名重复:
先说一个定义， 如果一个函数或变量已经定义过了，那么这个函数或变量就是 强类型； 如果只是声明，那么是弱类型。
当在不同模块的变量和函数出现命名冲突的时候：
1. 如果是两个强类型的冲突，那么就会报错。
2. 如果是一强一弱的冲突，那么就取强类型的那个变量。
3. 如果是两个弱类型的冲突，那么就会在几个弱类型里随机取一个。

### 2.2 方法重载
C语言是不支持方法重载的， 但在c++, java里，方法的重载的实现是，编译器将每个**唯一的“方法和参数列表”** 编码成一个对链接器来说唯一的名字。这种编码叫做“重整mangling”，反向过程叫恢复demangling.
```c++
Foo::bar(int, long);  ===> bar__3Fil  // bar是名， 3F是类名编码，i是int，l是long
```

### 2.3 链接器对多重定义符号的解析:
这一步要做的，就是匹配每一个模块里的外部引用。
在执行链接指令的时候，维护三个集合，分别是 文件集合E，未定义符号集合U，已定义符号D的集合。 
根据指令的文件输入顺序，遍历输入的 静态库文件/可重定向目标文件：
1. 如果是当前文件是可重定向目标文件: 
    放入E，更新U,D

2. 如果是静态库文件：
    遍历静态库文件里的每一个归档文件m，如果发现m能匹配掉U里的某个未定义符号，那么就取出，然后更新E，U，D

如果遍历完所有文件，未定义符号集合U非空，那么说明存在没找到的外部引用，则链接失败。

因此，在执行链接操作的时候，顺序也很重要，可以看出像是一个拓扑集，一般.a文件都是放在后面，错误的顺序会导致链接失败。

### 2.3 符号翻译得到什么
把每个“符号引用”和“一个符号定义”给对应了起来。


## 3. 链接的第二步骤： 重定向
重定向主要做的工作是：
1. 重定位节和符号定义： 根据符号翻译得到的结果，把这些不同模块类型相同的节给合并起来（例如.text的合并，.data的合并...） 得到一个聚合节
并更新函数或变量的地址。 这一步完成时， 程序的每个指令和每个变量都有了唯一的运行时内存地址了。

2. 重定位节中的符号引用： 重定位节就是elf里面的.rel.data和.rel.text。 重定位节由重定位条目组成， 每一个重定位条目可以理解成一个结构体，上面已经提到过了， 每一个条目对应一个全局变量或函数， 根据条目来找到对应全局遍历或函数的位置， 然后将这个位置上的跳转地址从 段内地址 更新成 逻辑地址(地址映射机构会把逻辑地址转换成物理地址)。 具体的转换过程参考csapp 479页. 
 
## 4. 静态链接， 动态链接，运行时链接
### 4.1 静态链接
在装载程序前，就已经链接完毕，就是静态链接。 尽管静态链接库解决了如何让大量相关函数对应用程序可用的问题，但它主要有两个缺点: 1. 如果库更新，那么还需要显式的重新链接； 2. 对于大部分程序都要用的库函数，每一份都会被复制到运行进程的文本段里，造成了资源浪费。 而共享库的出现就是为了解决这个问题，即动态链接。

### 4.2 动态链接
在把程序装载到内存的时候，才进行链接， 就是动态链接。  基本思路是，创建可执行文件的时候，先静态执行一部分链接，然后再程序加载的时候，动态的完成链接。 因此，在可执行程序里，并没有需要动态链接的库文件， 只有在加载的时候，才会链接起来然后装入内存中。。。 举几个特殊的情况： 一个程序先执行了很久，在快结束的时候，才调用那些几百上千行的库函数，那么在此之前，这些库函数都是没有被调用过的，占在内存中造成了资源浪费； 另外对于像服务器这种一旦装在入内存后，就要一直运行下去的情景下，动态链接无法满足动态内容的更改； 因此，运行时链接就出现了。。

### 4.3 运行时链接
在程序运行时，要求链接器加载和链接某个共享库，而无需编译时将那些库链接到应用程序中，这一链接方式叫动态运行时链接。

## 5. 在Java中调用C程序
```c
Java定义了一个标准调用规则，叫做Java本地接口，它允许Java程序调用本地的C/C++程序； 实现这个功能的基本思想是，先将本地的C/C++程序编译成一个共享库(.so)， 然后Java解释器，利用dlopen接口(或者功能类似的接口) 动态链接和加载该库 并调用.

上面提到的dlopen函数，是操作系统提供的一个接口函数(系统库函数)
```c
# include<dlfcn.h>
/*
    输入:
        filename : 为要加载并链接的共享库名字
        flag: 该参数必须要么包括RTLD_NOW, 即动态链接
                    要么为RTLD_LAZY，即动态运行时链接 

    返回:
        返回一个句柄，类型为void *
*/
void * dlopen( const char * filename, int flag );  

/*
    输入：
        handle参数为dlopen返回的那个句柄，
        symbol参数为符号名称， 即调用函数的名称或者变量的名称, 上面打开了共享库，这里就是
        在共享库里取出想使用的函数或变量。

    输出:
        返回符号的地址(即函数指针或变量的指针)
*/
void * dlsym( void * handle, char * symbol );

// 关闭句柄
int dlclose(void * handle); 
```

## 6. 库打桩机制
库打桩机制即： 截取对共享库函数的调用，取而代之执行自己的代码。 打桩可以发生在编译时，链接时，程序装入时，执行运行时。 这个了解即可，详见csapp p492

## 7. 小结
1. 链接器的两个主要任务是符号解析和重定位：
    1. 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义
    2. 重定位确定每个符号的最终内存地址(这个地址是逻辑地址)，并修改对目标的引用.

2. elf有三种: 可重定向目标文件，可执行文件，库文件